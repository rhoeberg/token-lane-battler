// This file is generated by running the atlas_builder.
package game

/*
Note: This file assumes the existence of a type Rect that defines a rectangle in the same package, it can defined as:

	Rect :: rl.Rectangle

or if you don't use raylib:

	Rect :: struct {
		x, y, width, height: f32,
	}

or if you want to use integers (or any other numeric type):

	Rect :: struct {
		x, y, width, height: int,
	}

Just make sure you have something along those lines the same package as this file.
*/

TEXTURE_ATLAS_FILENAME :: "atlas.png"
ATLAS_FONT_SIZE :: 32
LETTERS_IN_FONT :: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890?!&.,_:[]-+"

// A generated square in the atlas you can use with rl.SetShapesTexture to make
// raylib shapes such as rl.DrawRectangleRec() use the atlas.
SHAPES_TEXTURE_RECT :: Rect {190, 0, 10, 10}

Texture_Name :: enum {
	None,
	Archer,
	Test_Face,
	Rats,
	Cleaver,
	Healer,
	Bannerman,
	Spearman,
}

Atlas_Texture :: struct {
	rect: Rect,
	// These offsets tell you how much space there is between the rect and the edge of the original document.
	// The atlas is tightly packed, so empty pixels are removed. This can be especially apparent in animations where
	// frames can have different offsets due to different amount of empty pixels around the frames.
	// In many cases you need to add {offset_left, offset_top} to your position. But if you are
	// flipping a texture, then you might need offset_bottom or offset_right.
	offset_top: f32,
	offset_right: f32,
	offset_bottom: f32,
	offset_left: f32,
	document_size: [2]f32,
	duration: f32,
}

atlas_textures: [Texture_Name]Atlas_Texture = {
	.None = {},
	.Archer = { rect = {33, 0, 32, 32}, offset_top = 0, offset_right = 0, offset_bottom = 0, offset_left = 0, document_size = {32, 32}, duration = 0.100},
	.Test_Face = { rect = {66, 0, 31, 32}, offset_top = 0, offset_right = 1, offset_bottom = 0, offset_left = 0, document_size = {32, 32}, duration = 0.100},
	.Rats = { rect = {136, 0, 26, 27}, offset_top = 5, offset_right = 0, offset_bottom = 0, offset_left = 6, document_size = {32, 32}, duration = 0.100},
	.Cleaver = { rect = {0, 0, 32, 32}, offset_top = 0, offset_right = 0, offset_bottom = 0, offset_left = 0, document_size = {32, 32}, duration = 0.100},
	.Healer = { rect = {98, 0, 24, 30}, offset_top = 1, offset_right = 4, offset_bottom = 1, offset_left = 4, document_size = {32, 32}, duration = 0.100},
	.Bannerman = { rect = {163, 0, 26, 24}, offset_top = 8, offset_right = 1, offset_bottom = 0, offset_left = 5, document_size = {32, 32}, duration = 0.100},
	.Spearman = { rect = {123, 0, 12, 30}, offset_top = 2, offset_right = 10, offset_bottom = 0, offset_left = 10, document_size = {32, 32}, duration = 0.100},
}

Animation_Name :: enum {
	None,
}

Tag_Loop_Dir :: enum {
	Forward,
	Reverse,
	Ping_Pong,
	Ping_Pong_Reverse,
}

// Any aseprite file with frames will create new animations. Also, any tags
// within the aseprite file will make that that into a separate animation.
Atlas_Animation :: struct {
	first_frame: Texture_Name,
	last_frame: Texture_Name,
	document_size: [2]f32,
	loop_direction: Tag_Loop_Dir,
	repeat: u16,
}

atlas_animations := [Animation_Name]Atlas_Animation {
	.None = {},
}

Atlas_Glyph :: struct {
	rect: Rect,
	value: rune,
	offset_x: int,
	offset_y: int,
	advance_x: int,
}

atlas_glyphs: []Atlas_Glyph = {
}
